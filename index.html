<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<title>solitare single</title>
<meta name="description" content="" />
<meta name="generator" content="Studio 3 http://aptana.com/" />
<meta name="author" content="okzuo3" />
<meta name="viewport" content="width=320; user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
<style>
*{ margin:0px; padding:0px;position: absolute;}
a,
a:link
{
text-decoration:none;
color: black;
}
a:hover{
color: white;
}
a:active
{
text-decoration:none;
color: black;
}
.menu_item{
width : 105px;
height:14px;
font-size: 12px;
font-weight:bold;
text-align:center;
padding: 2px;
border:#ffffff 1px solid;
border-bottom: 1px solid orange;
background-color: silver;
}
#newgame{
left : 0px;
}
#endgame{
left : 105px;
}
#time_area{
left : 210px;
color : green;
}
#stage_canvas{
top: 20px;
left: 0px;
}
#off_canvas{
display: none;
}
</style>
<script type="text/javascript" src="List.js"></script>
<script type="text/javascript">
// グローバルメソッド
// エレメントを取得
function getelm(id) { return document.getElementById(id); }
// min, max 関数
function min(a,b){ return a<b ? a : b; }
function max(a,b){ return a>b ? a : b; }

// グローバル変数
var game_start=false; // ゲームが開始されると true に、終了時は false にセットされる
var wasteList = null; // 全カードを管理するリストクラス（山札でもある）
var tableauList = null; // 場札リストTableau
var aFoundationList = null; // 組み札リスト
var openWasteList = null; // 開いている山札リスト
var owDrawCount = 0; // 開いている山札の描画するカード数
var font_size = 16; // フォントサイズ
var back_color = 'rgb(192,192,254)'; // 背景色

var open_card_count=3; // 一度に開く山札の数

// 背景画像
var back_image = null;

// 場のサイズ、カードのサイズを求めておく
var stage_width = 320;
var stage_height = 340;
var card_space = 5;
var horz_margin = 5;
var card_width = Math.floor((stage_width - horz_margin*2) / 7 - card_space);
var card_height = Math.floor(card_width * 1.6);
var base_left = horz_margin + (stage_width - ((card_width*7) + (card_space*6) + horz_margin*2))/2;
var stage_left, stage_top;
var stage_canvas; // キャンバスエレメントを取得
var stage_con; // 描画用コンテキストを取得
var off_canvas; // オフスクリーンキャンバス
var off_con; // オフスクリーンコンテキスト
var draw_con; // 描画先のコンテキスト
var offscrnMode=false; // オフスクリーンモード

// ドラッグ用
var drag_mx = 0;
var drag_my = 0;
var drag_base_list = null;
var dragList = null; // ドラッグ中カードのリスト
var owDrawCountDist=0;
var drag_start = false; // クリックと判別できるようフラグを設ける 

// タイマー用
var start_time = 0;
var timerID = 0;
var show_secs=-1; // 前回表示した時間（秒数）

//矩形クラス
var Rect = function(left, top, width, height){
this.left = left!=null ? left : 0;
this.top = top!=null ? top : 0;
this.right = width!=null ? left + width : 0;
this.bottom = height!=null ? top + height : 0;
};
// 両方を含む矩形を返します
Rect.prototype.UnionRect = function(rect){
var newleft = rect.left < this.left ? rect.left : this.left;
var newright = rect.right > this.right ? rect.right : this.right;
var newtop = rect.top < this.top ? rect.top : this.top;
var newbottom = rect.bottom > this.bottom ? rect.bottom : this.bottom;
return new Rect( newleft, newtop, newright-newleft, newbottom-newtop );
};
// 交わる部分を返す
Rect.prototype.IntersectRect = function(rect){
var newleft = 0, newright = 0, newtop = 0, newbottom = 0;
if( rect.left < this.right && rect.top < this.bottom ){
newleft = max(rect.left,this.left);
newright = min(rect.right,this.right);
newtop = max(rect.top,this.top);
newbottom = min(rect.bottom,this.bottom);
}
return new Rect( newleft, newtop, newright-newleft, newbottom-newtop );
};
Rect.prototype.Width = function(){
return this.right - this.left; 
};
Rect.prototype.Height = function(){
return this.bottom - this.top;
};
Rect.prototype.IsRectEmpty = function(){
return (this.Width() == 0 || this.Height() == 0);
};
Rect.prototype.ptInRect = function(mx, my){
return ( this.left <= mx && mx <= this.right && this.top <= my && my<=this.bottom ); 
}

// カードアイテム
var CardItem = function(type,no,parentList,left,top){
this.type = type; // カード種別 S=スペード、D=ダイア, C=クラブ, H=ハート
this.no = no; // カード番号（1～13）
this.left = 0; // 表示の左座標
this.parentList = parentList; // 親リストを保持する（カードから辿れるように）
if( left != null ){
this.left = left;
}
this.top = 0; // 表示の上座標
if( top != null ){
this.top = top;
}
this.display = "close";
};
CardItem.prototype.setParentList = function(parentList){
this.parentList = parentList;
};
CardItem.prototype.getParentList = function(){
return this.parentList;
};
CardItem.prototype.draw = function( left, top ){
this.left = left;
this.top = top;
var frame_color;
if( this.display == "open" ){
// 背景を白色で描画
draw_con.fillStyle = 'white';
draw_con.fillRect( left, top, card_width, card_height );
if( this.type == 'D' || this.type == 'H' ){ // ダイヤ、ハートは赤で
draw_con.fillStyle = 'red';
}
else{
draw_con.fillStyle = 'black'; // スペード、クラブは黒
}
var card_no = this.no;
if( this.no > 10 ){ // １１以上は J, Q, K を表示
if( this.no == 13 ){
card_no = 'K';
}
else if( this.no == 12 ){
card_no = 'Q';
}
else{
card_no = 'J';
}
}
// Unicode文字でスペード、ハート、クラブ、ダイヤを表示する
var type_text = this.type=='S' ? "♠" : (this.type=='C' ? "♣" : (this.type=='H' ? "♥" : "♦" ));
var metrics = draw_con.measureText(type_text);
var mtc_no = draw_con.measureText(card_no);
draw_con.fillText( card_no, left+1, top+font_size );
draw_con.fillText( card_no, left+card_width-mtc_no.width-3, top+card_height-3 );
var right = left + card_width;
draw_con.fillText( type_text, right - metrics.width - 2, top+font_size ); 
draw_con.fillText( type_text, left+1, top+card_height-3 ); 
var large_font_size = font_size*2;
draw_con.font = large_font_size + "px 'Arial'";
metrics = draw_con.measureText(type_text);
draw_con.fillText( type_text, left+(card_width-metrics.width)/2, top+(card_height-metrics.width)/2+metrics.width );
draw_con.font = font_size + "px 'Arial'";
frame_color = 'gray';
}
else{
// 背景画像を描画する
draw_con.drawImage(back_image,left,top,card_width,card_height);
frame_color = 'white';
}
draw_con.lineWidth = 1;
draw_con.strokeStyle = frame_color;
draw_con.strokeRect( left, top, card_width, card_height );
};

CardItem.prototype.innerPoint = function(mx,my){
return ( this.left <= mx && mx <= this.left+card_width && this.top <= my && my<=this.top + card_height );
}
CardItem.prototype.innerCard = function(card){
// カードが重なるかをチェックする
var target_left = card.left;
var target_right = target_left + card_width;
var target_top = card.top;
var target_bottom = target_top + card_height;
if( target_left < this.left + card_width &&
this.left < target_right &&
target_top < this.top + card_height &&
this.top < target_bottom ){
return true; 
}
return false;
}

// リストクラスにシャッフル機能を追加する
List.prototype.get_from_index = function(index){
var count = 0;
var pos = this.get_top();
while( pos != null ){
if( count == index ) break;
pos = this.get_next(pos);
count++;
}
return pos;
};
List.prototype.shuffle = function(){
// いろいろアルゴリズムもあるだろうけど、カードゲームのようにランダムに選んだカードを一番最後へ移動させるという楽な手法を繰り返すことでシャッフルする
for(j=0;j<1000;j++){
var index = Math.floor(Math.random()*(this.get_length()));
if( index < this.get_length()-1 ){
var item = this.get_from_index(index);
if( item != null ){
if( this.top == item ){
this.top = item.next;
}
if( item.next != null ){
item.next.prev = item.prev;
}
if( item.prev != null ){
item.prev.next = item.next;
}
this.last.next = item;
item.prev = this.last;
item.next = null;
this.last = item;
}
} 
}
};
// リストにドロップ可能かチェックするメソッドを追加
List.prototype.canDrop = function(carditem,drag_count){
var bRet=false;
if( this.drop_card_type != 0 && null != carditem ){
if( this.last != null){
var lastitem = this.get_data(this.last);
if( this.drop_card_type == 1 || drag_count == 1 ){ // 組み札リスト上へは１枚しか移動できない
var last_type = lastitem.type;
var last_no = lastitem.no; 
if( this.drop_card_type == 1 ){ // 場札
if( last_no == carditem.no+1 && 
((last_type=='S' || last_type=='C') && (carditem.type=='D'||carditem.type=='H') ||
(last_type=='D' || last_type=='H') && (carditem.type=='S'||carditem.type=='C')) )
{
bRet = true;
}
}
else{ // 組み札
if( last_type == carditem.type && last_no == carditem.no-1 ){
bRet = true;
}
}
}
}
else{
// リストの先頭にドロップできるか?
if( (this.drop_card_type == 1 || drag_count == 1) && // 組み札リスト上へは１枚しか移動できない
this.drop_card_no == carditem.no )
{
bRet = true;
}
}
}
return bRet;
};
// 左上座標をリストに追加する(カードのないリストへドロップする際に使う)
List.prototype.pos_left = 0;
List.prototype.pos_top = 0;
List.prototype.drop_card_no = 0; // リストにカードがない場合にドロップできるカード番号
List.prototype.drop_card_type = 0; // リストに続いてドロップできるのは何か? 0=ドロップ不可能、1=場札(色違いで１つ小さい)、2=組み札(同種別で１つ大きい)

function InitCard(add){
if( timerID != 0 ){
clearInterval( timerID );
timerID = 0;
start_time = 0;
}
// 組み札をクリアする
if( aFoundationList == null ){
aFoundationList = new Array(4); // 組み札リスト配列
for(i=0;i<4;i++){
aFoundationList[i] = new List();
aFoundationList[i].drop_card_no = 1; // リストにカードがない場合にドロップできるカード番号
aFoundationList[i].drop_card_type = 2; // リストに続いてドロップできるのは何か? 0=ドロップ不可能、1=場札(色違いで１つ小さい)、2=組み札(同種別で１つ大きい)
}
}
else{
for(i=0;i<4;i++){
aFoundationList[i].remove_all();
}
}
// 場札をクリアする
if( tableauList == null ){
tableauList = new Array(7);
for( i=0; i<7; i++ ){
tableauList[i] = new List();
tableauList[i].drop_card_no = 13; // リストにカードがない場合にドロップできるカード番号
tableauList[i].drop_card_type = 1; // リストに続いてドロップできるのは何か? 0=ドロップ不可能、1=場札(色違いで１つ小さい)、2=組み札(同種別で１つ大きい)
}
}
else{
for( i=0; i<7; i++ ){
tableauList[i].remove_all();
tableauList[i].drop_card_no = 13; // リストにカードがない場合にドロップできるカード番号
tableauList[i].drop_card_type = 1; // リストに続いてドロップできるのは何か? 0=ドロップ不可能、1=場札(色違いで１つ小さい)、2=組み札(同種別で１つ大きい)
}
}
if( dragList == null ){
dragList = new List();
}
else{
dragList.remove_all();
}
var CardType = new Array( 'S', 'D', 'C', 'H' );
if( wasteList == null ){
wasteList = new List(); // 全カードを管理するリストクラス（山札でもある）
}
else{
wasteList.remove_all();
}
if( openWasteList == null ){ // 開いている山札
openWasteList = new List();
}
else{
openWasteList.remove_all();
}
if( add == true ){
// ５２枚のカードを追加する
for(t=0;t<CardType.length;t++){
for( i=1; i<=13; i++ ){
var card = new CardItem(CardType[t], i ,wasteList);
wasteList.add( card );
};
}
// カードをシャッフルする
wasteList.shuffle();
}
};
// 山札から場へカードを配る
function Distribute(){
// 山札の配列の 0 を一番下のカードとして配る
for(nstart=0; nstart<tableauList.length; nstart++ ){
for(i=nstart; i<tableauList.length; i++){
var pos = wasteList.get_last();
var carditem = wasteList.get_data(pos);
wasteList.remove( pos );
carditem.setParentList( tableauList[i] ); // 親リストを変更
tableauList[i].add( carditem );
if( i==nstart ){
carditem.display = "open";
}
}
}
};
function DrawStage(nodrawDragList){
if( offscrnMode == true ){
// オフスクリーンを描画
draw_con.drawImage(off_canvas,0,0);
}
else{
// 背景を描画
draw_con.fillStyle = back_color; // 'rgb(192,192,254)';
draw_con.fillRect(0,0,stage_width,stage_height);
draw_con.lineWidth = 1;
draw_con.strokeStyle = 'gray';
draw_con.strokeRect(0,0,stage_width,stage_height);
// 組み札(Foundation)の枠を描画する
var left = base_left; 
var top = card_space;
var count=0;
for( i=0; i<aFoundationList.length; i++, count++ ){
draw_con.strokeRect( left, top, card_width, card_height );
var pos = aFoundationList[i].get_top();
aFoundationList[i].pos_left = left;
aFoundationList[i].pos_top = top;
while( pos !=null ){
var carditem = aFoundationList[i].get_data(pos); 
carditem.draw(left,top);
pos = aFoundationList[i].get_next(pos);
}
left += card_width + card_space;
if( count == 3 ){
top += card_height + card_space;
left = base_left;
}
}
// 場札を描画する
left = base_left;
draw_con.font = font_size + "px 'Arial'";
for(i=0;i<tableauList.length;i++){
var top = (card_height + card_space) + card_space*2;
tableauList[i].pos_left = left;
tableauList[i].pos_top = top;
var pos = tableauList[i].get_top();
while( pos != null ){
var carditem = tableauList[i].get_data(pos);
if( carditem != null ){
carditem.draw(left,top);
pos = tableauList[i].get_next(pos);
top += font_size; // card_height / 5;
}
}
left += card_width + card_space;
}
// 山札を描画する
DrawWaste();
// 時間を描画しておく
ShowTime();
}
if( nodrawDragList == null || nodrawDragList == false ){
// ドラッグ中リストを描画する
var pos = dragList.get_top();
while( pos != null ){
var carditem = dragList.get_data(pos);
carditem.draw(carditem.left,carditem.top);
pos = dragList.get_next(pos);
}
}
};
// 山札を描画する
function DrawWaste(){
var left = tableauList[tableauList.length-1].pos_left;
var top = card_space+2;
wasteList.pos_left = left;
wasteList.pos_top = top;
// まず閉じている山を描画
var pos = wasteList.get_top();
if( pos != null ){ // １枚以上山に残っている場合
var btop = true;
while( pos != null ){
var carditem = wasteList.get_data(pos);
carditem.draw(left,top);
pos = wasteList.get_next(pos);
if( btop == true ){
left-=2;
top-=2;
btop = false;
}
}
}
else{ // カードがないので枠のみ描画する
draw_con.lineWidth = 1;
draw_con.strokeStyle = 'white';
draw_con.strokeRect( left, top, card_width, card_height );
}
// 開かれた山札を表示する
pos = openWasteList.get_last();
for(i=0; i<owDrawCount-1; i++){
if( pos==null || openWasteList.get_prev(pos) == null ){
break;
} 
pos = openWasteList.get_prev(pos);
}
left -= (card_width*2 + card_space);
top = card_space+2;
// まずはカードの描画先頭までを描画（座標指定）
var frontcard = openWasteList.get_top();
while(pos != frontcard){
var carditem = openWasteList.get_data(frontcard);
carditem.draw(left,top);
frontcard = openWasteList.get_next(frontcard);
}
while(pos!=null){
var carditem = wasteList.get_data(pos);
carditem.draw(left,top);
pos = wasteList.get_next(pos);
left += card_width/2;
top +=2;
}
};
// 山札を開く
function OpenWaste(redraw){
var pos = wasteList.get_last();
if( pos != null ){
for(i=0;pos!=null&&i<open_card_count;i++){
var carditem = wasteList.get_data(pos);
wasteList.remove(pos);
openWasteList.add( carditem );
carditem.setParentList(openWasteList);
carditem.display ="open";
pos = wasteList.get_last();
}
owDrawCount = i;
}
else{
// 山札が空なので開いている山札を全て戻す
pos = openWasteList.get_last();
while( pos != null ){
var carditem = openWasteList.get_data(pos);
openWasteList.remove( pos );
wasteList.add( carditem );
carditem.setParentList( wasteList );
carditem.display = "close";
pos = openWasteList.get_last();
}
owDrawCount = 0;
}
if( redraw != null && redraw == true ){
DrawStage();
}
};
// ヒットテスト
function HitTestOnCard(carditem, mx, my){
if( null != carditem ){
if( carditem.innerPoint(mx,my) ){
return carditem;
}
}
return null;
};
function HitTest(mx, my){
// 山札をチェック
var cardpos = wasteList.get_last();
var carditem = HitTestOnCard(wasteList.get_data(cardpos),mx,my); // 山札
if( carditem == null ){
cardpos = openWasteList.get_last();
carditem = HitTestOnCard( openWasteList.get_data(cardpos),mx,my ); // 開いた山札
if( carditem == null ){
// 場札は先頭（リストでは最後）と開いているカードの全てをチェックする
for(i=0;i<tableauList.length;i++){
var checkpos = tableauList[i].get_last();
var checkitem = tableauList[i].get_data(checkpos);
var bFirst=true; // 初回のみ開いてなくてもチェックする
while( carditem == null && checkitem != null && (bFirst || checkitem.display == "open") ){
carditem = HitTestOnCard(checkitem,mx,my );
if( null != carditem ) cardpos = checkpos;
checkpos = tableauList[i].get_prev(checkpos);
checkitem = tableauList[i].get_data(checkpos);
bFirst = false;
}
}
if( carditem == null ){
// 組み札をチェック
for( i=0; carditem==null && i<aFoundationList.length; i++ ){
cardpos = aFoundationList[i].get_last();
carditem = HitTestOnCard(aFoundationList[i].get_data(cardpos),mx,my );
}
}
}
}
if( carditem == null ) cardpos = null;
var ret = { pos: cardpos, item:carditem };
return ret;
};
// マウス、タップ処理
function getPosition( event, isMouse){
var mx, my;
if( isMouse ){
mx = event.clientX - stage_left;
my = event.clientY - stage_top;
} else {
if( event.touches.length != 0 ){
var t = event.touches[0];
mx = t.pageX - stage_left;
my = t.pageY - stage_top;
}
else{
mx = -1;
my = -1;
}
}
// 連想配列として返す
//var retVal = new Array();
//retVal['mx'] = mx;
//retVal['my'] = my;
//return retVal;
return { mx: mx, my: my };
};
// 山札かをチェックする
function isWasteArea(mx,my){
var left = wasteList.pos_left;
var top = wasteList.pos_top;
var width = card_width;
var height = card_height;
if( wasteList.get_length() > 1 ){
left -= 2;
top -= 2;
width += 2;
height += 2;
}
var rect = new Rect(left, top, width, height );
return rect.ptInRect( mx, my ); 
}
// 経過時間を取得する
// 連想配列で返す。
// seconds : 総秒数
// sec : 秒数(0～59)
// min : 分数(0～99)
function GetTimeSpan(){
var secs = 0;
if( start_time != 0 ){
var now = new Date();
var times = now.getTime() - start_time;
var secs = Math.floor(times/1000);
}
var sec = secs%60;
var minutes = Math.floor(secs/60);
var timespan = new Array();
timespan['min'] = minutes;
timespan['seconds'] = secs;
timespan['sec'] = sec;
return timespan;
}
// 経過時間を表示する
function ShowTime(){
var strTime = "Time 00:00";
var bShowTime=true;
if( start_time != 0 /*&& drag_start == false*/ ){
var bShowTime=false;
var now = new Date();
var times = now.getTime() - start_time;
var secs = Math.floor(times/1000);
if( secs > show_secs ){
show_secs = secs;
var sec = secs%60;
var minutes = Math.floor(secs/60);
var bShowSec = true;
strTime = "Time ";
if( minutes > 99 ){ // 99分以上は分だけ表示する
bShowSec=false;
}
else if( minutes < 10 ){
strTime +='0';
}
strTime += minutes;
if( bShowSec ){
strTime += ":";
if( sec < 10 ){
strTime += "0";
}
strTime += sec;
}
bShowTime = true;
}
}
if( bShowTime ){
var time_area = getelm("time_area");
time_area.innerHTML = strTime;
}
}
function onmousedown(event,isMouse){
event.preventDefault();
drag_start = false; // ここではドラッグフラグを立てない
if( game_start == false ){
return;
}
if( dragList.get_length() ){
// 以前のドラッグ状態が残ったまま・・・
// 元に戻す
if( dragList.get_length() ){
while( carditem != null ){
var nextcard = carditem.next;
dragList.remove(carditem);
drag_base_list.add( carditem );
carditem.setParentList(drag_base_list);
carditem = nextcard;
}
// 山札から持ってきた場合は山札の表示数も戻しておく
if( drag_base_list == openWasteList ){
owDrawCount+=owDrawCountDist;
owDrawCountDist = 0;
}
}
DrawStage();
}
var val = getPosition( event, isMouse);
var mx = val['mx'];
var my = val['my'];
if( mx == -1 && my== -1){return;}
if( start_time == 0 ){
var now = new Date();
start_time = now.getTime();
show_secs = -1;
timerID = setInterval("ShowTime()", 300 );
}
if( isWasteArea(mx,my) ){
// 山札
OpenWaste(true);
}
else{ 
var hit = HitTest( mx, my );
var hitcard = hit['item'];
var hitpos = hit['pos'];
if( hitcard != null ){
if( hitcard.display == "open" ){
// ドラッグ開始
drag_mx = mx;
drag_my = my;
drag_base_list = hitcard.getParentList(); // 親を取得
// 自分以降をドラッグリストへ追加
while( hitpos != null ){
var nextcard_pos = drag_base_list.get_next(hitpos);
if( nextcard_pos != null ){
var nextcard = drag_base_list.get_data(nextcard_pos);
}
drag_base_list.remove( hitpos );
dragList.add(hitcard);
hitcard.setParentList(dragList);
hitpos = nextcard_pos;
hitcard = drag_base_list.get_data(hitpos);
}
if( drag_base_list == openWasteList ){
owDrawCountDist = 0;
if( 1<owDrawCount ){
owDrawCount--;
owDrawCountDist = 1;
}
}
// オフスクリーンを用意する
draw_con = off_con;
DrawStage(true);
draw_con = stage_con;
offscrnMode = true;
}
else{
// 開く！
hitcard.display="open";
DrawStage();
}
}
}
};
function onmousemove(event,isMouse){
event.preventDefault();
if( game_start == false ){
return;
}
var val = getPosition( event, isMouse);
var mx = val['mx'];
var my = val['my'];
if( mx == -1 && my== -1){return;}
var pos = dragList.get_top();
if( pos != null ){
// ドラッグ中
drag_start = true; // ここでドラッグフラグを立てる！
var offset_x = mx - drag_mx;
var offset_y = my - drag_my;
if( offset_x != 0 || offset_y != 0 ){
while( pos != null ){
var carditem = dragList.get_data(pos);
pos = dragList.get_next(pos);
carditem.left += offset_x;
carditem.top += offset_y;
}
drag_mx = mx;
drag_my = my; 
DrawStage();
}
}
};
// list へ carditem をドロップできるか調べる。
function CheckDropList( list, carditem, intersect_size, drag_count ){
if( list.canDrop( carditem, drag_count ) ){
var card_rect = new Rect(carditem.left,carditem.top,card_width,card_height); 
var target_card = list.get_data(list.last);
var target_rect;
if( target_card != null ){
target_rect = new Rect( target_card.left, target_card.top, card_width, card_height );
}
else{
target_rect = new Rect( list.pos_left, list.pos_top, card_width, card_height );
}
var intersect_rect = target_rect.IntersectRect(card_rect);
var target_intersect_size = intersect_rect.Width() + intersect_rect.Height(); 
if( intersect_size < target_intersect_size ){
intersect_size = target_intersect_size;
}
}
return intersect_size;
};
// ドロップ処理
// ドロップ場所はドロップ可能な場所を優先する。
function OnDrop(mx,my){
// 場札、組札リストにドロップ可能かを問い合わせる。
var pos = dragList.get_top();
if( pos != null ){
var carditem = dragList.get_data(pos);
var target_list = null; // ドロップターゲットのリスト(これの後ろにつなげる)
if( drag_start == true ){ // ドラッグを開始した場合
// 場札リストにドロップできるかチェック
var intersect_size = 0;
var card_rect = new Rect(carditem.left,carditem.top,card_width,card_height); 
for(i=0;i<tableauList.length;i++){
var target_isize = CheckDropList( tableauList[i], carditem, intersect_size, dragList.get_length() );
if( intersect_size < target_isize ){
intersect_size = target_isize;
target_list = tableauList[i];
}
}
// 組み札リストにドロップできるか
for( i=0; i<aFoundationList.length; i++ ){
var target_isize = CheckDropList( aFoundationList[i], carditem, intersect_size, dragList.get_length() );
if( intersect_size < target_isize ){
intersect_size = target_isize;
target_list = aFoundationList[i];
}
}
}
else if( dragList.get_length() == 1 ){
// クリックされた場合は組み札へ移動できれば移動する
for( i=0; i<aFoundationList.length; i++ ){
var foundcard = aFoundationList[i].get_data(aFoundationList[i].get_last());
var nextcard_type = 'A';
var nextcard_no = 1; 
if( foundcard != null ){
nextcard_type = foundcard.type;
nextcard_no = foundcard.no + 1;
}
if( (nextcard_type == 'A' || nextcard_type == carditem.type) && nextcard_no == carditem.no ){
// ここに移動！
target_list = aFoundationList[i];
break;
}
}
}
if( target_list != null ){
// カードを移動させる
while( pos != null ){
var carditem = dragList.get_data(pos);
var next_pos = dragList.get_next(pos);
dragList.remove(pos);
target_list.add( carditem );
carditem.setParentList(target_list);
pos = next_pos;
}
}
else{
// 元に戻す
if( dragList.get_length() ){
while( pos != null ){
var carditem = dragList.get_data(pos);
var next_pos = dragList.get_next(pos);
dragList.remove(pos);
drag_base_list.add( carditem );
carditem.setParentList(drag_base_list);
pos = next_pos;
}
// 山札から持ってきた場合は山札の表示数も戻しておく
if( drag_base_list == openWasteList ){
owDrawCount+=owDrawCountDist;
owDrawCountDist = 0;
}
}
}
DrawStage();
}
};
function check_finish(){
// 全組み札の最後が 13 なら完成！！
var bFinish = true;
for( i=0; i<aFoundationList.length; i++ ){
var pos = aFoundationList[i].get_last();
if( pos != null ){
var carditem = aFoundationList[i].get_data(pos);
if( carditem.no != 13 ){
bFinish = false;
break;
}
}
else{
bFinish = false;
break;
}
}
return bFinish;
};
function ToMemory(totaltime){
// ローカルストレージの履歴を取得して、時間を比較する
/*
var times = localStorage.memory_times;
if( times == null ){
times = "";
}
alert(times);
// カンマ区切り
var time_array = times.split(",");
var index = time_array.length;
for( i=0;i<time_array.length;i++ ){
if( time_array[i] > totaltime ){
index = i;
}
}
if( index < 10 ){
time_array.splice(index,0,totaltime); // 配列へ挿入。splice( 開始インデックス, 削除する要素数, 追加要素, 追加要素, ...); 単なる挿入なら削除要素数を0にすればOK。
// 保存しなおす
times = "";
for(i=0;i<time_array.length;i++){
times += time_array[i].toString();
if( i+1 < time_array.length ){
times += ",";
}
}
localStorage.memory_times = times;
}
*/ 
}
function onmouseup(event,isMouse){
event.preventDefault();
if( game_start == false ){
return;
}
var val = getPosition( event, isMouse);
var mx = val['mx'];
var my = val['my'];
if( mx == -1 || my== -1){
mx = drag_mx;
my = drag_my;
}
offscrnMode = false;
OnDrop(mx,my);
drag_start = false;
// Finish をチェック
if( check_finish() ){
// 完成！！おめでとう！！
// クリア時間を取得
var timespan = GetTimeSpan();
if( timerID != 0 ){
clearInterval( timerID );
timerID = 0;
start_time = 0;
}
game_start = false;
// 履歴へ登録
ToMemory( timespan['seconds'] );
// 画面におめでとうを表示！！
var finish_message = "おめでとう！！ ";
if( timespan['min'] < 10 ){
finish_message += "0";
}
finish_message += timespan['min'] + ":";
if( timespan['sec'] < 10 ){
finish_message += "0";
}
finish_message += timespan['sec'];
draw_con.fillStyle = 'red';
var metrics = draw_con.measureText( finish_message );
var left = (stage_width - metrics.width)/2;
draw_con.fillText( finish_message, left, 200 );
}
};
function NewGame(){
// カードを初期化する
InitCard(true);
// カードを場に配る
Distribute();
// カードを表示する
DrawStage();
game_start = true;
};
function EndGame(){
if( timerID != 0 ){
clearInterval( timerID );
}
InitCard(false);
DrawStage();
game_start = false;
}
window.onload = function(){
stage_canvas = getelm( "stage_canvas" ); // キャンバスエレメントを取得
stage_con = stage_canvas.getContext("2d"); // 描画用コンテキストを取得
var bounds = stage_canvas.getBoundingClientRect();
stage_left = Math.floor(bounds.left);
stage_top = Math.floor(bounds.top);
// オフスクリーン用コンテキストを取得
off_canvas = getelm("off_canvas");
off_con = off_canvas.getContext("2d");
draw_con = stage_con;
// カードの背景画像を読み込む
back_image = new Image();
back_image.src = "img/card_back.png";
back_image.onload = function(){
NewGame();
};

// マウス・タップイベントを登録
stage_canvas.ontouchstart = function(e){ onmousedown(e,false); }
stage_canvas.ontouchmove = function(e){ onmousemove(e,false); }
stage_canvas.ontouchend = function(e){ onmouseup(e,false); }
stage_canvas.onmousedown = function(e){ onmousedown(e,true); }
stage_canvas.onmousemove = function(e){ onmousemove(e,true); }
stage_canvas.onmouseup = function(e){ onmouseup(e,true); }
stage_canvas.onmousedbleclick = function(e){ onmousedblclick(e,true); }
}
</script>
</head>
<body>
<div id="menu_bar">
<ul>
<li><a id="newgame" class="menu_item" href="#" onclick="NewGame();">New</a></li>
<li><a id="endgame" class="menu_item" href="#" onclick="EndGame();">End</a></li>
<li><span id="time_area" class="menu_item"></span></li>
</ul>
</div>
<div id="game_stage">
<canvas id="stage_canvas" width="320" height="340"></canvas>
<canvas id="off_canvas" width="320" height="340"></canvas>
</div>
</body>
</html>
